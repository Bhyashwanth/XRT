<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
  <title>XRT Native APIs &mdash; XRT 2020.2 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XRT Native Library C++ API" href="xrt_native.main.html" />
    <link rel="prev" title="Xilinx OpenCL extension" href="opencl_extension.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="index.html" class="icon icon-home"> XRT<img src="_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2020.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">XRT and Vitis™ Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building the XRT Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">XRT Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">Supported Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P)</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M)</a></li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">PCIe Slave-Bridge (SB)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xma_user_guide.html">Xilinx Media Accelerator (XMA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">XMA 19.2 Migration</a></li>
</ul>
<p class="caption"><span class="caption-text">User API Library</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="opencl_extension.html">Xilinx OpenCL extension</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XRT Native APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#device-and-xclbin">Device and XCLBIN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffers">Buffers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#buffer-allocation-and-deallocation">1. Buffer allocation and deallocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer-using-buffers">2. Data transfer using Buffers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api">I. Data transfer between host and device by Buffer read/write API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api">II. Data transfer between host and device by Buffer map API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iii-data-transfer-between-the-buffers-by-copy-api">III. Data transfer between the buffers by copy API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-other-buffer-apis">3. Miscellaneous other Buffer APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dma-buf-api">DMA-BUF API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sub-buffer-support">Sub-buffer support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-information">Buffer information</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kernel-and-run">Kernel and Run</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-kernel-handle-object-from-xclbin">Obtaining kernel handle/object from XCLBIN</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exclusive-access-of-the-kernel-s-cu">Exclusive access of the kernel’s CU</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#getting-bank-group-index-of-the-kernel-argument">Getting bank group index of the kernel argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-write-cu-mapped-registers">Reading and write CU mapped registers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#obtaining-the-argument-offset">Obtaining the argument offset</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#executing-the-kernel">Executing the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-kernel-execution-related-apis">Other kernel execution related APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph">Graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-opening-and-closing">Graph Opening and Closing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reset-functions">Reset Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-execution">Graph execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-execution-for-a-fixed-number-of-iterations">Graph execution for a fixed number of iterations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#infinite-graph-execution">Infinite Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measuring-aie-cycle-consumed-by-the-graph">Measuring AIE cycle consumed by the Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtp-runtime-parameter-control">RTP (Runtime Parameter) control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma-operation-to-and-from-global-memory-io">DMA operation to and from Global Memory IO</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#xrt-error-api">XRT Error API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html">XRT Native Library C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html#id1">XRT Native Library C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Core Library</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms_partitions.html">Alveo™ Platform Loading Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt.main.html">XRT Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil2.html">Xbutil Next Generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt2.html">Xbmgmt Next Generation</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">XRT Setup for Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>XRT Native APIs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/xrt_native_apis.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="xrt-native-apis">
<span id="xrt-native-apis-rst"></span><h1>XRT Native APIs<a class="headerlink" href="#xrt-native-apis" title="Permalink to this headline">¶</a></h1>
<p>From 2020.2 release XRT provides a new XRT API set in C, C++, and Python flavor. This document introduces the usability of C and C++ APIs.</p>
<p>To use the native XRT APIs, the host application must link with the <strong>xrt_coreutil</strong> library.</p>
<p>Example g++ command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>g++ -g -std<span class="o">=</span>c++14 -I<span class="nv">$XILINX_XRT</span>/include -L<span class="nv">$XILINX_XRT</span>/lib -o host.exe host.cpp -lxrt_coreutil -pthread
</pre></div>
</div>
<p>The core data structures in C and C++ are as below</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="31%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head">C++ Class</th>
<th class="head">C Type (Handle)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Device</td>
<td>xrt::device</td>
<td>xrtDeviceHandle</td>
</tr>
<tr class="row-odd"><td>XCLBIN</td>
<td>xrt::xclbin</td>
<td>xrtXclbinHandle</td>
</tr>
<tr class="row-even"><td>Buffer</td>
<td>xrt::bo</td>
<td>xrtBufferHandle</td>
</tr>
<tr class="row-odd"><td>Kernel</td>
<td>xrt::kernel</td>
<td>xrtKernelHandle</td>
</tr>
<tr class="row-even"><td>Run</td>
<td>xrt::run</td>
<td>xrtRunHandle</td>
</tr>
<tr class="row-odd"><td>Graph</td>
<td>TBD</td>
<td>xrtGraphHandle</td>
</tr>
</tbody>
</table>
<p>All the core data structures are defined inside in the header files at <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/experimental/</span></code> directory. In the user host code, it is sufficient to include <code class="docutils literal notranslate"><span class="pre">&quot;experimental/xrt_kernel.h&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;experimental/xrt_aie.h&quot;</span></code> (when using Graph APIs) to access all the APIs related to these data structure.</p>
<pre class="code c literal-block">
<span class="ln">5 </span>     <span class="comment preproc">#include</span> <span class="comment preprocfile">&quot;experimental/xrt_kernel.h&quot;</span><span class="comment preproc">
</span><span class="ln">6 </span><span class="comment preproc"></span>     <span class="comment preproc">#include</span> <span class="comment preprocfile">&quot;experimental/xrt_aie.h&quot;</span>
</pre>
<p>The common host code flow using the above data structures is as below</p>
<blockquote>
<div><ul class="simple">
<li>Open Xilinx <strong>Device</strong> and Load the <strong>XCLBIN</strong></li>
<li>Set up the <strong>Buffers</strong> that are used to transfer the data between the host and the device</li>
<li>Use the Buffer APIs for the data transfer between host and device (before and after the kernel execution).</li>
<li>Use <strong>Kernel</strong> and <strong>Run</strong> handle/objects to offload and manage the compute-intensive tasks running on FPGA.</li>
</ul>
</div></blockquote>
<p>Below we will walk through the common API usage to accomplish the above tasks.</p>
<div class="section" id="device-and-xclbin">
<h2>Device and XCLBIN<a class="headerlink" href="#device-and-xclbin" title="Permalink to this headline">¶</a></h2>
<p>Device and XCLBIN class provide fundamental infrastructure-related interfaces. The primary objective of the device and XCLBIN related APIs are</p>
<blockquote>
<div><ul class="simple">
<li>Open a Device</li>
<li>Load compiled kernel binary (or XCLBIN) onto the device</li>
</ul>
</div></blockquote>
<p>Example C API based code</p>
<pre class="code c literal-block">
<span class="ln">10 </span>     <span class="name">xrtDeviceHandle</span> <span class="name">device</span> <span class="operator">=</span> <span class="name">xrtDeviceOpen</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">11 </span>
<span class="ln">12 </span>     <span class="name">xrtXclbinHandle</span> <span class="name">xclbin</span> <span class="operator">=</span> <span class="name">xrtXclbinAllocFilename</span><span class="punctuation">(</span><span class="literal string">&quot;kernel.xclbin&quot;</span><span class="punctuation">);</span>
<span class="ln">13 </span>
<span class="ln">14 </span>     <span class="name">xrtDeviceLoadXclbinHandle</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span><span class="name">xclbin</span><span class="punctuation">);</span>
<span class="ln">15 </span>     <span class="punctuation">..............</span>
<span class="ln">16 </span>     <span class="punctuation">..............</span>
<span class="ln">17 </span>     <span class="name">xrtDeviceClose</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">);</span>
</pre>
<p>The above code block shows</p>
<blockquote>
<div><ul>
<li><p class="first">Opening the device (enumerated as 0) and get device handle <code class="docutils literal notranslate"><span class="pre">xrtDeviceHandle</span></code> (line 10)</p>
<blockquote>
<div><ul class="simple">
<li>Device indices are enumerated as 0,1,2 and can be observed by <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">scan</span></code></li>
</ul>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="n">xbutil</span> <span class="n">scan</span>
<span class="n">INFO</span><span class="p">:</span> <span class="n">Found</span> <span class="n">total</span> <span class="mi">2</span> <span class="n">card</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">2</span> <span class="n">are</span> <span class="n">usable</span>
<span class="o">.............</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="n">b3</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u250_gen3x16_base_1</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">129</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mi">0000</span><span class="p">:</span><span class="mi">65</span><span class="p">:</span><span class="mf">00.1</span> <span class="n">xilinx_u50_gen3x16_base_1</span> <span class="n">user</span><span class="p">(</span><span class="n">inst</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Opening the XCLBIN from the filename and get an XCLBIN handle <code class="docutils literal notranslate"><span class="pre">xrtXclbinHandle</span></code> (line 12)</p>
</li>
<li><p class="first">Loading the XCLBIN onto the Device by using the XCLBIN handle by API <code class="docutils literal notranslate"><span class="pre">xrtDeviceLoadXclbinHandle</span></code> (line 14)</p>
</li>
<li><p class="first">Closing the device handle at the end of the application (line 19)</p>
</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">10 </span>     <span class="keyword type">unsigned</span> <span class="keyword type">int</span> <span class="name">dev_index</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">11 </span>     <span class="keyword">auto</span> <span class="name">device</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">device</span><span class="punctuation">(</span><span class="name">dev_index</span><span class="punctuation">);</span>
<span class="ln">12 </span>     <span class="keyword">auto</span> <span class="name">xclbin_uuid</span> <span class="operator">=</span> <span class="name">device</span><span class="punctuation">.</span><span class="name">load_xclbin</span><span class="punctuation">(</span><span class="literal string">&quot;kernel.xclbin&quot;</span><span class="punctuation">);</span>
</pre>
<p>The above code block shows</p>
<blockquote>
<div><ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">xrt::device</span></code> class’s constructor is used to open the device</li>
<li>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> is used to load the XCLBIN from the filename.</li>
<li>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> returns the XCLBIN UUID, which is required to open the kernel (refer the Kernel Section).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<p>Buffers are primarily used to transfer the data between the host and the device. The Buffer related APIs are discussed in the following three subsections</p>
<blockquote>
<div><ol class="arabic simple">
<li>Buffer allocation and deallocation</li>
<li>Data transfer using Buffers</li>
<li>Miscellaneous other Buffer APIs</li>
</ol>
</div></blockquote>
<div class="section" id="buffer-allocation-and-deallocation">
<h3>1. Buffer allocation and deallocation<a class="headerlink" href="#buffer-allocation-and-deallocation" title="Permalink to this headline">¶</a></h3>
<p>XRT APIs provides API for</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code>: Allocates a buffer object 4K aligned, the API must be called with appropriate flags.</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBOAllocUserPtr</span></code>: Allocates a buffer object using pointer provided by the user. The user pointer must be aligned to 4K boundary.</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBOFree</span></code>: Deallocates the allocated buffer.</li>
</ul>
</div></blockquote>
<pre class="code c literal-block">
<span class="ln">15 </span>     <span class="name">xrtMemoryGroup</span> <span class="name">bank_grp_idx_0</span> <span class="operator">=</span> <span class="name">xrtKernelArgGroupId</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">16 </span>     <span class="name">xrtMemoryGroup</span> <span class="name">bank_grp_idx_1</span> <span class="operator">=</span> <span class="name">xrtKernelArgGroupId</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">);</span>
<span class="ln">17 </span>
<span class="ln">18 </span>     <span class="name">xrtBufferHandle</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">XRT_BO_FLAGS_NONE</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">19 </span>     <span class="name">xrtBufferHandle</span> <span class="name">output_buffer</span> <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">XRT_BO_FLAGS_NONE</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_1</span><span class="punctuation">);</span>
<span class="ln">20 </span>
<span class="ln">21 </span>     <span class="punctuation">....</span>
<span class="ln">22 </span>     <span class="punctuation">....</span>
<span class="ln">23 </span>     <span class="name">xrtBOFree</span><span class="punctuation">(</span><span class="name">input_buffer</span><span class="punctuation">);</span>
<span class="ln">24 </span>     <span class="name">xrtBOFree</span><span class="punctuation">(</span><span class="name">output_buffer</span><span class="punctuation">);</span>
</pre>
<p>The above code block shows</p>
<blockquote>
<div><ul class="simple">
<li>Buffer allocation API <code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code> at lines 15,16</li>
<li>Buffer deallocation API <code class="docutils literal notranslate"><span class="pre">xrtBOFree</span></code> at lines 23,24</li>
</ul>
</div></blockquote>
<p>The various arguments of the API <code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code> are</p>
<blockquote>
<div><ul>
<li><p class="first">Argument 1: The device on which the buffer should be allocated</p>
</li>
<li><p class="first">Argument 2: The size (in bytes) of the buffer</p>
</li>
<li><p class="first">Argument 3: <code class="docutils literal notranslate"><span class="pre">xrtBufferFlags</span></code>: Used to specify the buffer type, most commonly used types are</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_NONE</span></code>: Regular Buffer</li>
<li><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_DEV_ONLY</span></code>: Device only Buffer (meant to be used only by the kernel).</li>
<li><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_HOST_ONLY</span></code>: Host Only Buffer (buffers reside in the host memory directly transferred to/from the kernel)</li>
<li><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_P2P</span></code>: P2P Buffer, buffer for NVMe transfer</li>
<li><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_CACHEABLE</span></code>: Cacheable buffer can be used when host CPU frequently accessing the buffer (applicable for embedded platform).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">Argument 4:  <code class="docutils literal notranslate"><span class="pre">xrtMemoryGroup</span></code>: Enumerated Memory Bank to specify the location on the device where the buffer should be allocated. The <code class="docutils literal notranslate"><span class="pre">xrtMemoryGroup</span></code> is obtained by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgGroupId</span></code> as shown in line 15 (for more details of this API refer to the Kernel section).</p>
</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">15 </span>     <span class="keyword">auto</span> <span class="name">bank_grp_idx_0</span> <span class="operator">=</span> <span class="name">kernel</span><span class="punctuation">.</span><span class="name">group_id</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">16 </span>     <span class="keyword">auto</span> <span class="name">bank_grp_idx_1</span> <span class="operator">=</span> <span class="name">kernel</span><span class="punctuation">.</span><span class="name">group_id</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">);</span>
<span class="ln">17 </span>
<span class="ln">18 </span>     <span class="keyword">auto</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span><span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">19 </span>     <span class="keyword">auto</span> <span class="name">output_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_1</span><span class="punctuation">);</span>
</pre>
<p>In the above code <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> buffer objects are created using the class’s constructor. Note the buffer flag is not used as constructor by default created regular buffer. Nonetheless, the available buffer flags for <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> are described using <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument with the following enumerator values</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::normal</span></code>: Default, Regular Buffer</li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::device_only</span></code>: Device only Buffer (meant to be used only by the kernel).</li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::host_only</span></code>: Host Only Buffer (buffer resides in the host memory directly transferred to/from the kernel)</li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::p2p</span></code>: P2P Buffer, buffer for NVMe transfer</li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::cacheable</span></code>: Cacheable buffer can be used when host CPU frequently accessing the buffer (applicable for embedded platform).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="data-transfer-using-buffers">
<h3>2. Data transfer using Buffers<a class="headerlink" href="#data-transfer-using-buffers" title="Permalink to this headline">¶</a></h3>
<p>XRT Buffer API library provides a rich set of APIs helping the data transfers between the host and the device, between the buffers, etc. We will discuss the following data transfer style</p>
<blockquote>
<div><ol class="upperroman simple">
<li>Data transfer between host and device by Buffer read/write API</li>
<li>Data transfer between host and device by Buffer map API</li>
<li>Data transfer between buffers by copy API</li>
</ol>
</div></blockquote>
<div class="section" id="i-data-transfer-between-host-and-device-by-buffer-read-write-api">
<h4>I. Data transfer between host and device by Buffer read/write API<a class="headerlink" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api" title="Permalink to this headline">¶</a></h4>
<p>To transfer the data from the host to the device, the user first needs to update the host-side buffer backing pointer followed by a DMA transfer to the device.</p>
<p>The following C APIs are used for the above tasks</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtBOWrite</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></li>
</ol>
</div></blockquote>
<p>In C++, <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class has following member functions for the same functionality</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></li>
</ol>
</div></blockquote>
<p>To transfer the data from the device to the host, the steps are reverse, the user first needs to do a DMA transfer from the device followed by the reading data from the host-side buffer backing pointer.</p>
<p>The following C APIs are used for the above tasks</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBORead</span></code></li>
</ol>
</div></blockquote>
<p>In C++ the corresponding <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class’s member functions are</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code></li>
</ol>
</div></blockquote>
<p>Code example of transferring data from the host to the device</p>
<pre class="code c literal-block">
<span class="ln">20 </span>     <span class="name">xrtBufferHandle</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">XRT_BO_FLAGS_NONE</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">21 </span>
<span class="ln">22 </span>     <span class="comment single">// Prepare the input data
</span><span class="ln">23 </span><span class="comment single"></span>     <span class="keyword type">int</span> <span class="name">buff_data</span><span class="punctuation">[</span><span class="name">data_size</span><span class="punctuation">];</span>
<span class="ln">24 </span>     <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">i</span><span class="operator">=</span><span class="literal number integer">0</span><span class="punctuation">;</span> <span class="name">i</span><span class="operator">&lt;</span><span class="name">data_size</span><span class="punctuation">;</span> <span class="operator">++</span><span class="name">i</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">25 </span>         <span class="name">buff_data</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="name">i</span><span class="punctuation">;</span>
<span class="ln">26 </span>     <span class="punctuation">}</span>
<span class="ln">27 </span>
<span class="ln">28 </span>     <span class="name">xrtBOWrite</span><span class="punctuation">(</span><span class="name">input_buffer</span><span class="punctuation">,</span><span class="name">buff_data</span><span class="punctuation">,</span><span class="name">data_size</span><span class="operator">*</span><span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">),</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">29 </span>     <span class="name">xrtSyncBO</span><span class="punctuation">(</span><span class="name">input_buffer</span><span class="punctuation">,</span><span class="name">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="punctuation">,</span> <span class="name">data_size</span><span class="operator">*</span><span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">),</span><span class="literal number integer">0</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">20 </span>     <span class="keyword">auto</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">21 </span>     <span class="comment single">// Prepare the input data
</span><span class="ln">22 </span><span class="comment single"></span>     <span class="keyword type">int</span> <span class="name">buff_data</span><span class="punctuation">[</span><span class="name">data_size</span><span class="punctuation">];</span>
<span class="ln">23 </span>     <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword">auto</span> <span class="name">i</span><span class="operator">=</span><span class="literal number integer">0</span><span class="punctuation">;</span> <span class="name">i</span><span class="operator">&lt;</span><span class="name">data_size</span><span class="punctuation">;</span> <span class="operator">++</span><span class="name">i</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">24 </span>         <span class="name">buff_data</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="name">i</span><span class="punctuation">;</span>
<span class="ln">25 </span>     <span class="punctuation">}</span>
<span class="ln">26 </span>
<span class="ln">27 </span>     <span class="name">input_buffer</span><span class="punctuation">.</span><span class="name">write</span><span class="punctuation">(</span><span class="name">buff_data</span><span class="punctuation">);</span>
<span class="ln">28 </span>     <span class="name">input_buffer</span><span class="punctuation">.</span><span class="name">sync</span><span class="punctuation">(</span><span class="name">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="punctuation">);</span>
</pre>
<p>Note the C++ <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> etc has overloaded version that can be used for paritial buffer sync/read/write by specifying the size and the offset. For the above code example, the full buffer size and 0 offset are used as default arguments.</p>
</div>
<div class="section" id="ii-data-transfer-between-host-and-device-by-buffer-map-api">
<h4>II. Data transfer between host and device by Buffer map API<a class="headerlink" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtBOMap</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::map</span></code>) allows mapping the host-side buffer backing pointer to a user pointer. The host code can subsequently exercise the user pointer for the data reads and writes. However, after writing to the mapped pointer (or before reading from the mapped pointer) the API <code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>) should be used with direction flag for the DMA operation.</p>
<p>Code example of transferring data from the host to the device by this approach</p>
<pre class="code c literal-block">
<span class="ln">20 </span>     <span class="name">xrtBufferHandle</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">XRT_BO_FLAGS_NONE</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">21 </span>     <span class="keyword type">int</span><span class="operator">*</span> <span class="name">input_buffer_mapped</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="keyword type">int</span><span class="operator">*</span><span class="punctuation">)</span><span class="name">xrtBOMap</span><span class="punctuation">(</span><span class="name">input_buffer</span><span class="punctuation">);</span>
<span class="ln">22 </span>
<span class="ln">23 </span>     <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">i</span><span class="operator">=</span><span class="literal number integer">0</span><span class="punctuation">;</span><span class="name">i</span><span class="operator">&lt;</span><span class="name">data_size</span><span class="punctuation">;</span><span class="operator">++</span><span class="name">i</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">24 </span>         <span class="name">input_buffer_mappped</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="name">i</span><span class="punctuation">;</span>
<span class="ln">25 </span>     <span class="punctuation">}</span>
<span class="ln">26 </span>
<span class="ln">27 </span>     <span class="name">xrtBOSync</span><span class="punctuation">(</span><span class="name">input_buffer</span><span class="punctuation">,</span> <span class="name">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">20 </span>     <span class="keyword">auto</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">bank_grp_idx_0</span><span class="punctuation">);</span>
<span class="ln">21 </span>     <span class="keyword">auto</span> <span class="name">input_buffer_mapped</span> <span class="operator">=</span> <span class="name">input_buffer</span><span class="punctuation">.</span><span class="name">map</span><span class="operator">&lt;</span><span class="keyword type">int</span><span class="operator">*&gt;</span><span class="punctuation">();</span>
<span class="ln">22 </span>
<span class="ln">23 </span>     <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword">auto</span> <span class="name">i</span><span class="operator">=</span><span class="literal number integer">0</span><span class="punctuation">;</span><span class="name">i</span><span class="operator">&lt;</span><span class="name">data_size</span><span class="punctuation">;</span><span class="operator">++</span><span class="name">i</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">24 </span>         <span class="name">input_buffer_mapped</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="name">i</span><span class="punctuation">;</span>
<span class="ln">25 </span>     <span class="punctuation">}</span>
<span class="ln">26 </span>
<span class="ln">27 </span>     <span class="name">input_buffer</span><span class="punctuation">.</span><span class="name">sync</span><span class="punctuation">(</span><span class="name">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="punctuation">);</span>
</pre>
</div>
<div class="section" id="iii-data-transfer-between-the-buffers-by-copy-api">
<h4>III. Data transfer between the buffers by copy API<a class="headerlink" href="#iii-data-transfer-between-the-buffers-by-copy-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides <code class="docutils literal notranslate"><span class="pre">xrtBOCopy</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy</span></code>) API for deep copy between the two buffer objects if the platform supports a deep-copy (for detail refer M2M feature described in <a class="reference internal" href="m2m.html#m2m-rst"><span class="std std-ref">Memory-to-Memory (M2M)</span></a>). If deep copy is not supported by the platform the data transfer happens by shallow copy (the data transfer happens via host).</p>
<p>API Example in C, all arguments are self-explanatory</p>
<pre class="code c literal-block">
<span class="ln">25 </span>     <span class="keyword type">size_t</span> <span class="name">dst_buffer_offset</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">26 </span>     <span class="keyword type">size_t</span> <span class="name">src_buffer_offset</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">27 </span>     <span class="name">xrtBOCopy</span><span class="punctuation">(</span><span class="name">dst_buffer</span><span class="punctuation">,</span> <span class="name">src_buffer</span><span class="punctuation">,</span> <span class="name">size_of_copy</span><span class="punctuation">,</span> <span class="name">dst_buffer_offset</span><span class="punctuation">,</span> <span class="name">src_buffer_offset</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">25 </span>     <span class="name">dst_buffer</span><span class="punctuation">.</span><span class="name">copy</span><span class="punctuation">(</span><span class="name">src_buffer</span><span class="punctuation">,</span> <span class="name">copy_size_in_bytes</span><span class="punctuation">);</span>
</pre>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy</span></code> also has overloaded version to provide a different offset than 0 for both the source and the destination buffer.</p>
</div>
</div>
<div class="section" id="miscellaneous-other-buffer-apis">
<h3>3. Miscellaneous other Buffer APIs<a class="headerlink" href="#miscellaneous-other-buffer-apis" title="Permalink to this headline">¶</a></h3>
<p>This section describes a few other specific use-cases using buffers.</p>
<div class="section" id="dma-buf-api">
<h4>DMA-BUF API<a class="headerlink" href="#dma-buf-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides Buffer export and import APIs primarily used for sharing buffer across devices (P2P application) and processes.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtBOExport</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code>): Export the buffer to an exported buffer handle</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBOImport</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> constructor) : Allocate a BO imported from exported buffer handle</li>
</ul>
</div></blockquote>
<p>Consider the situation of exporting buffer from device 1 to device 2.</p>
<pre class="code c literal-block">
<span class="ln">18 </span>     <span class="name">xclBufferExportHandle</span> <span class="name">buffer_exported</span> <span class="operator">=</span> <span class="name">xrtBOExport</span><span class="punctuation">(</span><span class="name">buffer_device_1</span><span class="punctuation">);</span>
<span class="ln">19 </span>     <span class="name">xrtBufferHandle</span> <span class="name">buffer_device_2</span> <span class="operator">=</span> <span class="name">xrtBOImport</span><span class="punctuation">(</span><span class="name">device_2</span><span class="punctuation">,</span> <span class="name">buffer_exported</span><span class="punctuation">);</span>
</pre>
<p>In the above example</p>
<blockquote>
<div><ul class="simple">
<li>The buffer buffer_device_1 is a buffer allocated on device 1</li>
<li>buffer_device_1 is exported to an <code class="docutils literal notranslate"><span class="pre">xclBufferExportHandle</span></code> by API <code class="docutils literal notranslate"><span class="pre">xrtBOExport</span></code></li>
<li>The exported buffer of type <code class="docutils literal notranslate"><span class="pre">xclBufferExportHandle</span></code> is imported to device 2 by API <code class="docutils literal notranslate"><span class="pre">xrtBOImport</span></code></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<pre class="code c++ literal-block">
<span class="ln">18 </span>     <span class="keyword">auto</span> <span class="name">buffer_exported</span> <span class="operator">=</span> <span class="name">buffer_device_1</span><span class="punctuation">.</span><span class="name">export_buffer</span><span class="punctuation">();</span>
<span class="ln">19 </span>     <span class="keyword">auto</span> <span class="name">buffer_device_2</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device_2</span><span class="punctuation">,</span> <span class="name">buffer_exported</span><span class="punctuation">);</span>
</pre>
<p>In the above example</p>
<blockquote>
<div><ul class="simple">
<li>The buffer buffer_device_1 is a buffer allocated on device 1</li>
<li>buffer_device_1 is exported by the member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code></li>
<li>The new buffer buffer_device_2 is imported for device_2 by the constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sub-buffer-support">
<h4>Sub-buffer support<a class="headerlink" href="#sub-buffer-support" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtBOSubAlloc</span></code> (C++: supported by an <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class constructor) allocates a sub-buffer from a parent buffer by specifying a start offset and the size.</p>
<p>In the example below a sub-buffer is created from a parent buffer of size 4 bytes staring from its offset 0</p>
<pre class="code c literal-block">
<span class="ln">18 </span>     <span class="name">xrtBufferHandle</span> <span class="name">parent_buffer</span><span class="punctuation">;</span>
<span class="ln">19 </span>     <span class="name">xrtBufferHandle</span> <span class="name">sub_buffer</span><span class="punctuation">;</span>
<span class="ln">20 </span>
<span class="ln">21 </span>     <span class="keyword type">size_t</span> <span class="name">sub_buffer_size</span> <span class="operator">=</span> <span class="literal number integer">4</span><span class="punctuation">;</span>
<span class="ln">22 </span>     <span class="keyword type">size_t</span> <span class="name">sub_buffer_offset</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">23 </span>
<span class="ln">24 </span>     <span class="name">sub_buffer</span> <span class="operator">=</span> <span class="name">xrtBOSubAlloc</span><span class="punctuation">(</span><span class="name">parent_buffer</span><span class="punctuation">,</span> <span class="name">sub_buffer_size</span><span class="punctuation">,</span> <span class="name">sub_buffer_offset</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<p>In C++ a sub-buffer is created by using the xrt::bo class’s constructor using the parent buffer, size, and offset as parameters.</p>
<pre class="code c++ literal-block">
<span class="ln">18 </span>     <span class="keyword type">size_t</span> <span class="name">sub_buffer_size</span> <span class="operator">=</span> <span class="literal number integer">4</span><span class="punctuation">;</span>
<span class="ln">19 </span>     <span class="keyword type">size_t</span> <span class="name">sub_buffer_offset</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">20 </span>
<span class="ln">21 </span>     <span class="keyword">auto</span> <span class="name">sub_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">parent_buffer</span><span class="punctuation">,</span> <span class="name">sub_buffer_size</span><span class="punctuation">,</span> <span class="name">sub_buffer_offset</span><span class="punctuation">);</span>
</pre>
</div>
<div class="section" id="buffer-information">
<h4>Buffer information<a class="headerlink" href="#buffer-information" title="Permalink to this headline">¶</a></h4>
<p>XRT provides few other APIs to obtain information related to the buffer.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtBOSize</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::size</span></code>): Size of the buffer</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtBOAddr</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::address</span></code>) : Physical address of the buffer</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="kernel-and-run">
<h2>Kernel and Run<a class="headerlink" href="#kernel-and-run" title="Permalink to this headline">¶</a></h2>
<p>The XRT kernel APIs support creating of kernel handle (or object in C++) from currently loaded xclbin.  The kernel handle is used to execute the kernel function on the hardware instance (Compute Unit or CU) of the kernel.</p>
<p>A Run handle/object represents an execution of the kernel. Upon finishing the kernel execution, the Run handle/object can be reused to invoke the same kernel function if desired.</p>
<p>The following topics are discussed below</p>
<blockquote>
<div><ul class="simple">
<li>Obtaining kernel handle/object from XCLBIN</li>
<li>Getting the bank group index of a kernel argument</li>
<li>Reading and write CU mapped registers</li>
<li>Execution of kernel and dealing with the associated run</li>
<li>Other kernel execution related API</li>
</ul>
</div></blockquote>
<div class="section" id="obtaining-kernel-handle-object-from-xclbin">
<h3>Obtaining kernel handle/object from XCLBIN<a class="headerlink" href="#obtaining-kernel-handle-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The kernel handle (or object) is created from the device, XCLBIN UUID and the kernel name.</p>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="name">xuid_t</span> <span class="name">xclbin_uuid</span><span class="punctuation">;</span>
<span class="ln">36 </span>     <span class="name">xrtXclbinGetUUID</span><span class="punctuation">(</span><span class="name">xclbin</span><span class="punctuation">,</span><span class="name">xclbin_uuid</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="name">xrtKernelHandle</span> <span class="name">kernel</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpen</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;kernel_name&quot;</span><span class="punctuation">);</span>
<span class="ln">39 </span>     <span class="punctuation">....</span>
<span class="ln">40 </span>     <span class="punctuation">....</span>
<span class="ln">41 </span>     <span class="name">xrtKernelClose</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">);</span>
</pre>
<p>In the above code example</p>
<blockquote>
<div><ul class="simple">
<li>The UUID of the XCLBIN is retrieved by the API <code class="docutils literal notranslate"><span class="pre">xrtXclbinGetUUID</span></code></li>
<li>The kernel is created by the API <code class="docutils literal notranslate"><span class="pre">xrtPLKernelOpen</span></code></li>
<li>The kernel is closed by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelClose</span></code></li>
</ul>
</div></blockquote>
<p><strong>Note</strong>: For the kernel with more than 1 CU, a kernel handle (or object) should represent all the CUs having identical interface connectivity. If all the CUs of the kernel are not having identical connectivity, the specific CU name(s) should be used to obtain a kernel handle (or object) to represent the subset of CUs with identical connectivity. Otherwise XRT will do this selection internally to select a group of CUs and discard the rest of the CUs (discarded CUs are not used during the execution of a kernel).</p>
<p>As an example, assume a kernel name is foo having 3 CUs foo_1, foo_2, foo_3. The CUs foo_1 and foo_2 are connected to DDR bank 0, but the CU foo_3 is connected to DDR bank 1.</p>
<blockquote>
<div><ul>
<li><p class="first">Opening kernel handle for foo_1 and foo_2 (as they have identical interface connection)</p>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="name">cu_group_1</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpen</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_1,foo_2}&quot;</span><span class="punctuation">);</span>
</pre>
</li>
<li><p class="first">Opening kernel handle for foo_3</p>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="name">cu_group_2</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpen</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_3}&quot;</span><span class="punctuation">);</span>
</pre>
</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: In C++, <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> object can be created from the constructor of <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class.</p>
<pre class="code c++ literal-block">
<span class="ln">35 </span>     <span class="keyword">auto</span> <span class="name">xclbin_uuid</span> <span class="operator">=</span> <span class="name">device</span><span class="punctuation">.</span><span class="name">load_xclbin</span><span class="punctuation">(</span><span class="literal string">&quot;kernel.xclbin&quot;</span><span class="punctuation">);</span>
<span class="ln">36 </span>     <span class="keyword">auto</span> <span class="name">krnl</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">kernel</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="name">name</span><span class="punctuation">);</span>
</pre>
<div class="section" id="exclusive-access-of-the-kernel-s-cu">
<h4>Exclusive access of the kernel’s CU<a class="headerlink" href="#exclusive-access-of-the-kernel-s-cu" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtPLKernelOpen</span></code> opens a kernel’s CU in a shared mode so that the CU can be shared with the other processes. In some cases, it is required to open the CU in exclusive mode (for example, when it is required to read/write CU mapped register). Exclusive CU opening fails if the CU is already opened in either shared or exclusive access.</p>
<pre class="code c literal-block">
<span class="ln">39 </span>     <span class="name">xrtKernelHandle</span> <span class="name">kernel</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpenExclusive</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;name&quot;</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: In C++, <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> constructor can be called with an additional <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument to access the kernel in exclusive mode. The enumerator values are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrt::kernel::cu_access_mode::shared</span></code> (default <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> constructor argument)</li>
<li><code class="docutils literal notranslate"><span class="pre">xrt::kernel::cu_access_mode::exclusive</span></code></li>
</ul>
</div></blockquote>
<pre class="code c++ literal-block">
<span class="ln">39 </span>     <span class="keyword">auto</span> <span class="name">krnl</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">kernel</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="name">name</span><span class="punctuation">,</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">kernel</span><span class="operator">::</span><span class="name">cu_access_mode</span><span class="operator">::</span><span class="name">exclusive</span><span class="punctuation">);</span>
</pre>
</div>
</div>
<div class="section" id="getting-bank-group-index-of-the-kernel-argument">
<h3>Getting bank group index of the kernel argument<a class="headerlink" href="#getting-bank-group-index-of-the-kernel-argument" title="Permalink to this headline">¶</a></h3>
<p>We have seen in the Buffer creation section that it is required to provide the buffer location during the buffer creation. XRT provides an API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgGroupId</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id</span></code>) that returns the bank index (ID) of a specific argument of the kernel. This ID is used as the last argument of <code class="docutils literal notranslate"><span class="pre">xclAllocBO</span></code> (in C++ with <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> constructor) API to create the buffer on the same memory bank.</p>
<p>Let us review the example below where the buffer is allocated for the kernel’s first (argument index 0) by using this API</p>
<pre class="code c literal-block">
<span class="ln">39 </span>     <span class="name">xrtMemoryGroup</span> <span class="name">idx_0</span> <span class="operator">=</span> <span class="name">xrtKernelArgGroupId</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span> <span class="comment single">// bank index of 0th argument
</span><span class="ln">40 </span><span class="comment single"></span>     <span class="name">xrtBufferHandle</span> <span class="name">a</span> <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">data_size</span><span class="operator">*</span><span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">int</span><span class="punctuation">),</span> <span class="name">XRT_BO_FLAGS_NONE</span><span class="punctuation">,</span> <span class="name">idx_0</span><span class="punctuation">);</span>
</pre>
<pre class="code c++ literal-block">
<span class="ln">15 </span>     <span class="keyword">auto</span> <span class="name">input_buffer</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">bo</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">buffer_size_in_bytes</span><span class="punctuation">,</span> <span class="name">kernel</span><span class="punctuation">.</span><span class="name">group_id</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">));</span>
</pre>
<p>The API fails if the kernel bank index is ambiguous. For example, the kernel has multiple CU with different connectivity for that argument. In those cases, it is required to create a kernel object/handle with specific a CU (or group of CUs with identical connectivity).</p>
</div>
<div class="section" id="reading-and-write-cu-mapped-registers">
<h3>Reading and write CU mapped registers<a class="headerlink" href="#reading-and-write-cu-mapped-registers" title="Permalink to this headline">¶</a></h3>
<p>To read and write from the AXI-Lite register space corresponding to a CU, the CU must be opened in exclusive mode (in shared mode, multiple processes can access the CU’s address space, hence it is unsafe if they are trying to access/change registers at the same time leading to a potential race behavior). The required APIs for kernel register read and write are</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtKernelReadRegister</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::read_register</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtKernelWriteRegiste</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::write_register</span></code>)</li>
</ul>
</div></blockquote>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="keyword type">int</span> <span class="name">read_data</span><span class="punctuation">;</span>
<span class="ln">36 </span>     <span class="keyword type">int</span> <span class="name">write_data</span> <span class="operator">=</span> <span class="literal number integer">7</span><span class="punctuation">;</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="name">xrtKernelHandle</span> <span class="name">kernel</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpenExclusive</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_1}&quot;</span><span class="punctuation">);</span>
<span class="ln">39 </span>
<span class="ln">40 </span>     <span class="name">xrtKernelReadRegister</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span><span class="name">READ_OFFSET</span><span class="punctuation">,</span><span class="operator">&amp;</span><span class="name">read_data</span><span class="punctuation">);</span>
<span class="ln">41 </span>     <span class="name">xrtKernelWriteRegister</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span><span class="name">WRITE_OFFSET</span><span class="punctuation">,</span><span class="name">write_data</span><span class="punctuation">);</span>
<span class="ln">42 </span>
<span class="ln">43 </span>     <span class="name">xrtKernelClose</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">);</span>
</pre>
<p>In the above code block</p>
<blockquote>
<div><ul class="simple">
<li>The CU named “foo_1” (name syntax: “kernel_name:{cu_name}”) is opened exclusively.</li>
<li>The Register Read/Write operation is performed.</li>
<li>Closed the kernel</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API example</p>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="keyword type">int</span> <span class="name">read_data</span><span class="punctuation">;</span>
<span class="ln">36 </span>     <span class="keyword type">int</span> <span class="name">write_data</span> <span class="operator">=</span> <span class="literal number integer">7</span><span class="punctuation">;</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="keyword">auto</span> <span class="name">krnl</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">kernel</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_1}&quot;</span><span class="punctuation">,</span> <span class="name builtin">true</span><span class="punctuation">);</span>
<span class="ln">39 </span>
<span class="ln">40 </span>     <span class="name">read_data</span> <span class="operator">=</span> <span class="name">kernel</span><span class="punctuation">.</span><span class="name">read_register</span><span class="punctuation">(</span><span class="name">READ_OFFSET</span><span class="punctuation">);</span>
<span class="ln">41 </span>     <span class="name">kernel</span><span class="punctuation">.</span><span class="name">write_register</span><span class="punctuation">(</span><span class="name">WRITE_OFFSET</span><span class="punctuation">,</span><span class="name">write_data</span><span class="punctuation">);</span>
</pre>
<div class="section" id="obtaining-the-argument-offset">
<h4>Obtaining the argument offset<a class="headerlink" href="#obtaining-the-argument-offset" title="Permalink to this headline">¶</a></h4>
<p>The register read/write access APIs use the register offset as shown in the above examples. The user can get the register offset of a corresponding kernel argument from the <code class="docutils literal notranslate"><span class="pre">v++</span></code> generated <code class="docutils literal notranslate"><span class="pre">.xclbin.info</span></code> file and use with the register read/write APIs.</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--------------------------</span>
<span class="n">Instance</span><span class="p">:</span>        <span class="n">foo_1</span>
<span class="n">Base</span> <span class="n">Address</span><span class="p">:</span> <span class="mh">0x1800000</span>

<span class="n">Argument</span><span class="p">:</span>          <span class="n">a</span>
<span class="n">Register</span> <span class="n">Offset</span><span class="p">:</span>   <span class="mh">0x10</span>
</pre></div>
</div>
<p>However, XRT also provides APIs to obtain the register offset for CU arguments. In the below example C API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgOffset</span></code> is used to obtain offset of third argument of the CU <code class="docutils literal notranslate"><span class="pre">foo:foo_1</span></code>.</p>
<pre class="code c literal-block">
<span class="ln">38 </span>     <span class="comment single">// Assume foo has 3 arguments, a,b,c (arg 0, arg 1 and arg 2 respectively)
</span><span class="ln">39 </span><span class="comment single"></span>
<span class="ln">40 </span>     <span class="name">xrtKernelHandle</span> <span class="name">kernel</span> <span class="operator">=</span> <span class="name">xrtPLKernelOpenExclusive</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_1}&quot;</span><span class="punctuation">);</span>
<span class="ln">41 </span>     <span class="keyword type">uint32_t</span> <span class="name">arg_c_offset</span> <span class="operator">=</span> <span class="name">xrtKernelArgOffset</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span> <span class="literal number integer">2</span><span class="punctuation">);</span>
</pre>
<p><strong>C++</strong>: The equivalent C++ API example</p>
<pre class="code c++ literal-block">
<span class="ln">38 </span>     <span class="comment single">// Assume foo has 3 arguments, a,b,c (arg 0, arg 1 and arg 2 respectively)
</span><span class="ln">39 </span><span class="comment single"></span>
<span class="ln">40 </span>     <span class="keyword">auto</span> <span class="name">krnl</span> <span class="operator">=</span> <span class="name">xrt</span><span class="operator">::</span><span class="name">kernel</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;foo:{foo_1}&quot;</span><span class="punctuation">,</span> <span class="name builtin">true</span><span class="punctuation">);</span>
<span class="ln">41 </span>     <span class="keyword">auto</span> <span class="name">offset</span> <span class="operator">=</span> <span class="name">krnl</span><span class="punctuation">.</span><span class="name">offset</span><span class="punctuation">(</span><span class="literal number integer">2</span><span class="punctuation">);</span>
</pre>
</div>
</div>
<div class="section" id="executing-the-kernel">
<h3>Executing the kernel<a class="headerlink" href="#executing-the-kernel" title="Permalink to this headline">¶</a></h3>
<p>Execution of the kernel is associated with a <strong>Run</strong> handle (or object). The kernel can be executed by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> (in C++ overloaded operator <code class="docutils literal notranslate"><span class="pre">xrt::kernel::operator()</span></code>) that takes all the kernel arguments in order. The kernel execution API returns a run handle (or object) corresponding to the execution.</p>
<pre class="code c literal-block">
<span class="ln">50 </span>     <span class="comment single">// 1st kernel execution
</span><span class="ln">51 </span><span class="comment single"></span>     <span class="name">xrtRunHandle</span> <span class="name">run</span> <span class="operator">=</span> <span class="name">xrtKernelRun</span><span class="punctuation">(</span><span class="name">kernel</span><span class="punctuation">,</span> <span class="name">buf_a</span><span class="punctuation">,</span> <span class="name">buf_b</span><span class="punctuation">,</span>  <span class="name">scalar_1</span><span class="punctuation">);</span>
<span class="ln">52 </span>     <span class="name">xrtRunWait</span><span class="punctuation">(</span><span class="name">run</span><span class="punctuation">);</span>
<span class="ln">53 </span>
<span class="ln">54 </span>     <span class="comment single">// 2nd kernel execution with just changing 3rd argument
</span><span class="ln">55 </span><span class="comment single"></span>     <span class="name">xrtRunSetArg</span><span class="punctuation">(</span><span class="name">run</span><span class="punctuation">,</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="name">scalar_2</span><span class="punctuation">);</span> <span class="comment single">// Arguments are specified starting from 0
</span><span class="ln">56 </span><span class="comment single"></span>     <span class="name">xrtRunStart</span><span class="punctuation">(</span><span class="name">run</span><span class="punctuation">);</span>
<span class="ln">57 </span>     <span class="name">xrtRunWait</span><span class="punctuation">(</span><span class="name">run</span><span class="punctuation">);</span>
<span class="ln">58 </span>
<span class="ln">59 </span>     <span class="comment single">// Close the run handle
</span><span class="ln">60 </span><span class="comment single"></span>     <span class="name">xrtRunClose</span><span class="punctuation">(</span><span class="name">run</span><span class="punctuation">);</span>
</pre>
<p>Note the following APIs regarding  the above example</p>
<blockquote>
<div><ul>
<li><p class="first">The kernel is executed by <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> API by specifying all its arguments to obtain a Run handle</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> is non-blocking. It returns as soon as it submits the job without waiting for the kernel’s actual execution start.</p>
</li>
<li><p class="first">The host code uses <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> API to block the current thread and wait till the kernel execution is finished.</p>
</li>
<li><p class="first">After a run is finished, the same run handle can be reused to execute the kernel multiple times if desired.</p>
<blockquote>
<div><ul class="simple">
<li>API <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> is used to set one or more arguments, in the example above only the last (3rd) argument is changed before the second execution</li>
<li>API <code class="docutils literal notranslate"><span class="pre">xrtRunStart</span></code> is used to execute the kernel using the run handle.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">API <code class="docutils literal notranslate"><span class="pre">xrtRunClose</span></code> is used to close the Run handle.</p>
</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ code</p>
<p>In C++ the <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class provides <strong>overloaded operator ()</strong> to execute the kernel with a comma-separated list of arguments.</p>
<pre class="code c++ literal-block">
<span class="ln">50 </span>     <span class="comment single">// 1st kernel execution
</span><span class="ln">51 </span><span class="comment single"></span>     <span class="keyword">auto</span> <span class="name">run</span> <span class="operator">=</span> <span class="name">kernel</span><span class="punctuation">(</span><span class="name">buf_a</span><span class="punctuation">,</span> <span class="name">buf_b</span><span class="punctuation">,</span> <span class="name">scalar_1</span><span class="punctuation">);</span>
<span class="ln">52 </span>     <span class="name">run</span><span class="punctuation">.</span><span class="name">wait</span><span class="punctuation">();</span>
<span class="ln">53 </span>
<span class="ln">54 </span>     <span class="comment single">// 2nd kernel execution with just changing 3rd argument
</span><span class="ln">55 </span><span class="comment single"></span>     <span class="name">run</span><span class="punctuation">.</span><span class="name">set_arg</span><span class="punctuation">(</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="name">scalar_2</span><span class="punctuation">);</span> <span class="comment single">// Arguments are specified starting from 0
</span><span class="ln">56 </span><span class="comment single"></span>     <span class="name">run</span><span class="punctuation">.</span><span class="name">start</span><span class="punctuation">();</span>
<span class="ln">57 </span>     <span class="name">run</span><span class="punctuation">.</span><span class="name">wait</span><span class="punctuation">();</span>
</pre>
<p>The above c++ code block is demonstrating</p>
<blockquote>
<div><ul class="simple">
<li>The kernel execution using the <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> operator with the list of arguments that returns a xrt::run object. This is an asynchronous API and returns after submitting the task.</li>
<li>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait</span></code> is used to block the current thread until the current execution is finished.</li>
<li>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code> is used to set one or more kernel argument(s) before the next execution. In the example above, only the last (3rd) argument is changed.</li>
<li>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start</span></code> is used to start the next kernel execution with new argument(s).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="other-kernel-execution-related-apis">
<h3>Other kernel execution related APIs<a class="headerlink" href="#other-kernel-execution-related-apis" title="Permalink to this headline">¶</a></h3>
<p>The Run handle/object supports few other use-cases.</p>
<p><strong>Obtaining the run handle/object before execution</strong>: In the above example we have seen a run handle/object is obtained when the kernel is executed (kernel execution returns a run handle/object). However, a run handle can be obtained even before the kernel execution. The flow is as below</p>
<blockquote>
<div><ul class="simple">
<li>Open a Run handle (or object) by API <code class="docutils literal notranslate"><span class="pre">xrtRunOpen</span></code> (in C++ <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> constructor with a kernel argument). There is no kernel execution associated with this run handle/object yet</li>
<li>Set the kernel arguments associated for the next execution by <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code>).</li>
<li>Execute the kernel by <code class="docutils literal notranslate"><span class="pre">xrtRunStart</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start</span></code>).</li>
<li>Wait for the execution finish by <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::run::wait</span></code>).</li>
</ul>
</div></blockquote>
<p><strong>Timeout while wait for kernel finish</strong>: The API <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> blocks the current thread until the kernel execution finishes. However, a timeout supported API <code class="docutils literal notranslate"><span class="pre">xrtRunWaitFor</span></code> is also provided . The timeout number can be specified using a millisecond unit.</p>
<p>In C++, the timeout facility can be used by the same member function that takes a <code class="docutils literal notranslate"><span class="pre">std::chrono::milliseconds</span></code> to specify the timeout.</p>
<p><strong>Asynchronous update of the kernel arguments</strong>: The API <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code>) is synchronous to the kernel execution. This API can only be used when kernel is in the IDLE state and before the start of the next execution. An asynchronous version of this API (only for edge platform) <code class="docutils literal notranslate"><span class="pre">xrtRunUpdateArg</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::update_arg</span></code>) is provided to change the kernel arguments asynchronous to the kernel execution.</p>
</div>
</div>
<div class="section" id="graph">
<h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<p>In Versal ACAPs with AI Engines, the XRT Graph APIs can be used to dynamically load, monitor, and control the graphs executing on the AI Engine array. As of the 2020.2 release, XRT provides a set of C APIs for graph control. The C++ APIs are planned for a future release. Also, as of the 2020.2 release Graph APIs are only supported on the Edge platform.</p>
<p>A graph handle is of type <code class="docutils literal notranslate"><span class="pre">xrtGraphHandle</span></code>.</p>
<div class="section" id="graph-opening-and-closing">
<h3>Graph Opening and Closing<a class="headerlink" href="#graph-opening-and-closing" title="Permalink to this headline">¶</a></h3>
<p>The XRT graph APIs support the obtaining of graph handle from currently loaded xclbin. The required APIs for graph open and close are</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtGraphOpen</span></code>: API provides the handle of the graph from the device, XCLBIN UUID, and the graph name.</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtGraphClose</span></code>: API to close the graph handle.</li>
</ul>
</div></blockquote>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="name">xuid_t</span> <span class="name">xclbin_uuid</span><span class="punctuation">;</span>
<span class="ln">36 </span>     <span class="name">xrtXclbinGetUUID</span><span class="punctuation">(</span><span class="name">xclbin</span><span class="punctuation">,</span><span class="name">xclbin_uuid</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="name">xrtGraphHandle</span> <span class="name">graph</span> <span class="operator">=</span> <span class="name">xrtGraphOpen</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;graph_name&quot;</span><span class="punctuation">);</span>
<span class="ln">39 </span>     <span class="punctuation">....</span>
<span class="ln">40 </span>     <span class="punctuation">....</span>
<span class="ln">41 </span>     <span class="name">xrtGraphClose</span><span class="punctuation">(</span><span class="name">graph</span><span class="punctuation">);</span>
</pre>
<p>The graph handle obtained from <code class="docutils literal notranslate"><span class="pre">xrtGraphOpen</span></code> is used to execute the graph function on the AIE tiles.</p>
</div>
<div class="section" id="reset-functions">
<h3>Reset Functions<a class="headerlink" href="#reset-functions" title="Permalink to this headline">¶</a></h3>
<p>There are two reset functions are used:</p>
<blockquote>
<div><ul class="simple">
<li>API <code class="docutils literal notranslate"><span class="pre">xrtAIEResetArray</span></code> is used to reset the whole AIE array.</li>
<li>API <code class="docutils literal notranslate"><span class="pre">xrtGraphReset</span></code> is used to reset a specified graph by disabling tiles and enabling tile reset.</li>
</ul>
</div></blockquote>
<pre class="code c literal-block">
<span class="ln">45 </span>     <span class="name">xrtDeviceHandle</span> <span class="name">device_handle</span> <span class="operator">=</span> <span class="name">xrtDeviceOpen</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">46 </span>     <span class="punctuation">...</span>
<span class="ln">47 </span>     <span class="comment single">// AIE Array Reset
</span><span class="ln">48 </span><span class="comment single"></span>     <span class="name">xrtAIEResetArray</span><span class="punctuation">(</span><span class="name">device_handle</span><span class="punctuation">)</span>
<span class="ln">49 </span>
<span class="ln">50 </span>     <span class="name">xrtGraphHandle</span> <span class="name">graph</span> <span class="operator">=</span> <span class="name">xrtGraphOpen</span><span class="punctuation">(</span><span class="name">device</span><span class="punctuation">,</span> <span class="name">xclbin_uuid</span><span class="punctuation">,</span> <span class="literal string">&quot;graph_name&quot;</span><span class="punctuation">);</span>
<span class="ln">51 </span>     <span class="comment single">// Graph Reset
</span><span class="ln">52 </span><span class="comment single"></span>     <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
</pre>
</div>
<div class="section" id="graph-execution">
<h3>Graph execution<a class="headerlink" href="#graph-execution" title="Permalink to this headline">¶</a></h3>
<p>XRT provides basic graph execution control APIs to initialize, run, wait, and terminate graphs for a specific number of iterations. Below we will review some of the common graph execution styles.</p>
<div class="section" id="graph-execution-for-a-fixed-number-of-iterations">
<h4>Graph execution for a fixed number of iterations<a class="headerlink" href="#graph-execution-for-a-fixed-number-of-iterations" title="Permalink to this headline">¶</a></h4>
<p>A graph can be executed for a fixed number of iterations followed by a “busy-wait” or a “time-out wait”.</p>
<p><strong>Busy Wait scheme</strong></p>
<p>The graph can be executed for a fixed number of iteration by <code class="docutils literal notranslate"><span class="pre">xrtGraphRun</span></code> API using an iteration argument. Subsequently, <code class="docutils literal notranslate"><span class="pre">xrtGraphWait</span></code> or <code class="docutils literal notranslate"><span class="pre">xrtGraphEnd</span></code> API should be used (with argument 0) to wait until graph execution is completed.</p>
<p>Let’s review the below example</p>
<ul>
<li><p class="first">The graph is executed for 3 iterations by API <code class="docutils literal notranslate"><span class="pre">xrtGraphRun</span></code> with the number of iterations as an argument.</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphWait(graphHandle,0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li>The API <cite>xrtGraphWait</cite> is used because the host code needs to execute the graph again.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The Graph is executed again for 5 iteration</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphEnd(graphHandle,0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li>After <code class="docutils literal notranslate"><span class="pre">xrtGraphEnd</span></code> the same graph should not be executed.</li>
</ul>
</div></blockquote>
</li>
</ul>
<pre class="code c literal-block">
<span class="ln">35 </span>     <span class="comment single">// start from reset state
</span><span class="ln">36 </span><span class="comment single"></span>     <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="comment single">// run the graph for 3 iteration
</span><span class="ln">39 </span><span class="comment single"></span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">3</span><span class="punctuation">);</span>
<span class="ln">40 </span>
<span class="ln">41 </span>     <span class="comment single">// Wait till the graph is done
</span><span class="ln">42 </span><span class="comment single"></span>     <span class="name">xrtGraphWait</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">0</span><span class="punctuation">);</span>  <span class="comment single">// Use xrtGraphWait if you want to execute the graph again
</span><span class="ln">43 </span><span class="comment single"></span>
<span class="ln">44 </span>
<span class="ln">45 </span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">5</span><span class="punctuation">);</span>
<span class="ln">46 </span>     <span class="name">xrtGraphEnd</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">0</span><span class="punctuation">);</span>  <span class="comment single">// Use xrtGraphEnd if you are done with the graph execution</span>
</pre>
<p><strong>Timeout wait scheme</strong></p>
<p>As shown in the above example <code class="docutils literal notranslate"><span class="pre">xrtGraphWait(graphHandle,0)</span></code> performs a busy-wait and suspend the execution till the graph is not done. If desired a timeout version of the wait can be achieved by <code class="docutils literal notranslate"><span class="pre">xrtGraphWaitDone</span></code> which can be used to wait for some specified number of milliseconds, and if the graph is not done do something else in the meantime. An example is shown below</p>
<pre class="code c++ literal-block">
<span class="ln">35 </span>     <span class="comment single">// start from reset state
</span><span class="ln">36 </span><span class="comment single"></span>     <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="comment single">// run the graph for 100 iteration
</span><span class="ln">39 </span><span class="comment single"></span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">100</span><span class="punctuation">);</span>
<span class="ln">40 </span>
<span class="ln">41 </span>      <span class="keyword">while</span> <span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">42 </span>       <span class="keyword">auto</span> <span class="name">rval</span>  <span class="operator">=</span> <span class="name">xrtGraphWaitDone</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">5</span><span class="punctuation">);</span>
<span class="ln">43 </span>        <span class="name">std</span><span class="operator">::</span><span class="name">cout</span> <span class="operator">&lt;&lt;</span> <span class="literal string">&quot;Wait for graph done returns: &quot;</span> <span class="operator">&lt;&lt;</span> <span class="name">rval</span> <span class="operator">&lt;&lt;</span> <span class="name">std</span><span class="operator">::</span><span class="name">endl</span><span class="punctuation">;</span>
<span class="ln">44 </span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rval</span> <span class="operator">==</span> <span class="operator">-</span><span class="name">ETIME</span><span class="punctuation">)</span>  <span class="punctuation">{</span>
<span class="ln">45 </span>             <span class="name">std</span><span class="operator">::</span><span class="name">cout</span> <span class="operator">&lt;&lt;</span> <span class="literal string">&quot;Timeout, reenter......&quot;</span> <span class="operator">&lt;&lt;</span> <span class="name">std</span><span class="operator">::</span><span class="name">endl</span><span class="punctuation">;</span>
<span class="ln">46 </span>             <span class="comment single">// Do something
</span><span class="ln">47 </span><span class="comment single"></span>        <span class="punctuation">}</span>
<span class="ln">48 </span>        <span class="keyword">else</span>  <span class="comment single">// Graph is done, quit the loop
</span><span class="ln">49 </span><span class="comment single"></span>            <span class="keyword">break</span><span class="punctuation">;</span>
<span class="ln">50 </span>       <span class="punctuation">}</span>
</pre>
</div>
<div class="section" id="infinite-graph-execution">
<h4>Infinite Graph Execution<a class="headerlink" href="#infinite-graph-execution" title="Permalink to this headline">¶</a></h4>
<p>The graph runs infinitely if <code class="docutils literal notranslate"><span class="pre">xrtGraphRun</span></code> is called with iteration argument -1. While a graph running infinitely the APIs <code class="docutils literal notranslate"><span class="pre">xrtGraphWait</span></code>, <code class="docutils literal notranslate"><span class="pre">xrtGraphSuspend</span></code> and xrtGraphEnd can be used to suspend/end the graph operation after some number of AIE cycles. The API <code class="docutils literal notranslate"><span class="pre">xrtGraphResume</span></code> is used to execute the infinitely running graph again.</p>
<pre class="code c literal-block">
<span class="ln">39 </span>     <span class="comment single">// start from reset state
</span><span class="ln">40 </span><span class="comment single"></span>     <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">41 </span>
<span class="ln">42 </span>     <span class="comment single">// run the graph infinitely
</span><span class="ln">43 </span><span class="comment single"></span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="operator">-</span><span class="literal number integer">1</span><span class="punctuation">);</span>
<span class="ln">44 </span>
<span class="ln">45 </span>     <span class="name">xrtGraphWait</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">3000</span><span class="punctuation">);</span>  <span class="comment single">// Suspends the graph after 3000 AIE cycles from the previous start
</span><span class="ln">46 </span><span class="comment single"></span>
<span class="ln">47 </span>
<span class="ln">48 </span>     <span class="name">xrtGraphResume</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span> <span class="comment single">// Restart the suspended graph again to run forever
</span><span class="ln">49 </span><span class="comment single"></span>
<span class="ln">50 </span>     <span class="name">xrtGraphSuspend</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span> <span class="comment single">// Suspend the graph immediately
</span><span class="ln">51 </span><span class="comment single"></span>
<span class="ln">52 </span>     <span class="name">xrtGraphResume</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span> <span class="comment single">// Restart the suspended graph again to run forever
</span><span class="ln">53 </span><span class="comment single"></span>
<span class="ln">54 </span>     <span class="name">xrtGraphEnd</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">5000</span><span class="punctuation">);</span>  <span class="comment single">// End the graph operation after 5000 AIE cycles from the previous start</span>
</pre>
<p>In the example above</p>
<ul>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphRun(graphHandle,</span> <span class="pre">-1)</span></code> is used to execute the graph infinitely</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphWait(graphHandle,3000)</span></code> suspends the graph after 3000 AIE cycles from the graph starts.</p>
<blockquote>
<div><ul class="simple">
<li>If the graph was already run more than 3000 AIE cycles the graph is suspended immediately.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphResume</span></code> is used to restart the suspended graph</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphSuspend</span></code> is used to suspend the graph immediately</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtGraphEnd(graphHandle,5000)</span></code> is  ending the graph after 5000 AIE cycles from the previous graph start.</p>
<blockquote>
<div><ul class="simple">
<li>If the graph was already run more than 5000 AIE cycles the graph ends immediately.</li>
<li>Using <code class="docutils literal notranslate"><span class="pre">xrtGraphEnd</span></code> eliminates the capability of rerunning the Graph (without loading PDI and a graph reset again).</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="measuring-aie-cycle-consumed-by-the-graph">
<h3>Measuring AIE cycle consumed by the Graph<a class="headerlink" href="#measuring-aie-cycle-consumed-by-the-graph" title="Permalink to this headline">¶</a></h3>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtGraphTimeStamp</span></code> can be used to determine AIE cycle consumed between a graph start and stop.</p>
<p>Here in this example, the AIE cycle consumed by 3 iteration is calculated</p>
<pre class="code c++ literal-block">
<span class="ln">35 </span>     <span class="comment single">// start from reset state
</span><span class="ln">36 </span><span class="comment single"></span>     <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="keyword type">uint64_t</span> <span class="name">begin_t</span> <span class="operator">=</span> <span class="name">xrtGraphTimeStamp</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">39 </span>
<span class="ln">40 </span>     <span class="comment single">// run the graph for 3 iteration
</span><span class="ln">41 </span><span class="comment single"></span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">3</span><span class="punctuation">);</span>
<span class="ln">42 </span>
<span class="ln">43 </span>     <span class="name">xrtGraphWait</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">44 </span>
<span class="ln">45 </span>     <span class="keyword type">uint64_t</span> <span class="name">end_t</span> <span class="operator">=</span> <span class="name">xrtGraphTimeStamp</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">46 </span>
<span class="ln">47 </span>     <span class="name">std</span><span class="operator">::</span><span class="name">cout</span><span class="operator">&lt;&lt;</span><span class="literal string">&quot;Number of AIE cycles consumed in the 3 iteration is: &quot;</span><span class="operator">&lt;&lt;</span> <span class="name">end_t</span><span class="operator">-</span><span class="name">begin_t</span><span class="punctuation">;</span>
</pre>
</div>
<div class="section" id="rtp-runtime-parameter-control">
<h3>RTP (Runtime Parameter) control<a class="headerlink" href="#rtp-runtime-parameter-control" title="Permalink to this headline">¶</a></h3>
<p>XRT provides the API to update and read the runtime parameters of the graph.</p>
<ul class="simple">
<li>The API <code class="docutils literal notranslate"><span class="pre">xrtGraphUpdateRTP</span></code> to update the RTP</li>
<li>The API <code class="docutils literal notranslate"><span class="pre">xrtGraphReadRTP</span></code> to read the RTP.</li>
</ul>
<pre class="code c++ literal-block">
<span class="ln">35 </span>     <span class="name">ret</span> <span class="operator">=</span> <span class="name">xrtGraphReset</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">);</span>
<span class="ln">36 </span>     <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">ret</span><span class="punctuation">)</span> <span class="keyword">throw</span> <span class="name">std</span><span class="operator">::</span><span class="name">runtime_error</span><span class="punctuation">(</span><span class="literal string">&quot;Unable to reset graph&quot;</span><span class="punctuation">);</span>
<span class="ln">37 </span>
<span class="ln">38 </span>     <span class="name">ret</span> <span class="operator">=</span> <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal number integer">2</span><span class="punctuation">);</span>
<span class="ln">39 </span>     <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">ret</span><span class="punctuation">)</span> <span class="keyword">throw</span> <span class="name">std</span><span class="operator">::</span><span class="name">runtime_error</span><span class="punctuation">(</span><span class="literal string">&quot;Unable to run graph&quot;</span><span class="punctuation">);</span>
<span class="ln">40 </span>
<span class="ln">41 </span>     <span class="keyword type">float</span> <span class="name">increment</span><span class="punctuation">[</span><span class="literal number integer">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="punctuation">{</span><span class="literal number integer">1</span><span class="punctuation">};</span>
<span class="ln">42 </span>     <span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*</span><span class="name">inVect</span> <span class="operator">=</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*&gt;</span><span class="punctuation">(</span><span class="name">increment</span><span class="punctuation">);</span>
<span class="ln">43 </span>     <span class="name">xrtGraphUpdateRTP</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal string">&quot;mm.mm0.in[2]&quot;</span><span class="punctuation">,</span> <span class="name">inVect</span><span class="punctuation">,</span> <span class="keyword">sizeof</span> <span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">));</span>
<span class="ln">44 </span>
<span class="ln">45 </span>     <span class="comment single">// Do more things
</span><span class="ln">46 </span><span class="comment single"></span>     <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">16</span><span class="punctuation">);</span>
<span class="ln">47 </span>     <span class="name">xrtGraphWait</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">48 </span>
<span class="ln">49 </span>     <span class="comment single">// Read RTP
</span><span class="ln">50 </span><span class="comment single"></span>     <span class="keyword type">float</span> <span class="name">increment_out</span><span class="punctuation">[</span><span class="literal number integer">1</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="punctuation">{</span><span class="literal number integer">1</span><span class="punctuation">};</span>
<span class="ln">51 </span>     <span class="keyword type">char</span> <span class="operator">*</span><span class="name">outVect</span> <span class="operator">=</span> <span class="keyword">reinterpret_cast</span><span class="operator">&lt;</span><span class="keyword type">char</span> <span class="operator">*&gt;</span><span class="punctuation">(</span><span class="name">increment_out</span><span class="punctuation">);</span>
<span class="ln">52 </span>     <span class="name">xrtGraphReadRTP</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="literal string">&quot;mm.mm0.inout[0]&quot;</span><span class="punctuation">,</span> <span class="name">outVect</span><span class="punctuation">,</span> <span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">));</span>
<span class="ln">53 </span>     <span class="name">std</span><span class="operator">::</span><span class="name">cout</span><span class="operator">&lt;&lt;</span><span class="literal string">&quot;</span><span class="literal string escape">\n</span><span class="literal string"> RTP value read&lt;&lt;increment_out[0];</span>
</pre>
<p>In the above example, the API <code class="docutils literal notranslate"><span class="pre">xrtGraphUpdateRTP</span></code> and <code class="docutils literal notranslate"><span class="pre">xrtGraphReadRTP</span></code> are used to update and read the RTP values respectively. Note the API arguments</p>
<blockquote>
<div><ul class="simple">
<li>The hierarchical name of the RTP port</li>
<li>Pointer to write or read the RTP variable</li>
<li>The size of the RTP value.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="dma-operation-to-and-from-global-memory-io">
<h3>DMA operation to and from Global Memory IO<a class="headerlink" href="#dma-operation-to-and-from-global-memory-io" title="Permalink to this headline">¶</a></h3>
<p>XRT provides API <code class="docutils literal notranslate"><span class="pre">xrtAIESyncBO</span></code> to synchronize the buffer contents between GMIO and AIE. The following code shows a sample example</p>
<pre class="code c++ literal-block">
<span class="ln">35 </span>     <span class="name">xrtDeviceHandle</span> <span class="name">device_handle</span> <span class="operator">=</span> <span class="name">xrtDeviceOpen</span><span class="punctuation">(</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">36 </span>
<span class="ln">37 </span>     <span class="comment single">// Buffer from GM to AIE
</span><span class="ln">38 </span><span class="comment single"></span>     <span class="name">xrtBufferHandle</span> <span class="name">in_bo_handle</span>  <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device_handle</span><span class="punctuation">,</span> <span class="name">SIZE</span> <span class="operator">*</span> <span class="keyword">sizeof</span> <span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">),</span> <span class="literal number integer">0</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">39 </span>
<span class="ln">40 </span>     <span class="comment single">// Buffer from AIE to GM
</span><span class="ln">41 </span><span class="comment single"></span>     <span class="name">xrtBufferHandle</span> <span class="name">out_bo_handle</span>  <span class="operator">=</span> <span class="name">xrtBOAlloc</span><span class="punctuation">(</span><span class="name">device_handle</span><span class="punctuation">,</span> <span class="name">SIZE</span> <span class="operator">*</span> <span class="keyword">sizeof</span> <span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">),</span> <span class="literal number integer">0</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">42 </span>
<span class="ln">43 </span>     <span class="name">inp_bo_map</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="keyword type">float</span> <span class="operator">*</span><span class="punctuation">)</span><span class="name">xrtBOMap</span><span class="punctuation">(</span><span class="name">in_bo_handle</span><span class="punctuation">);</span>
<span class="ln">44 </span>     <span class="name">out_bo_map</span> <span class="operator">=</span> <span class="punctuation">(</span><span class="keyword type">float</span> <span class="operator">*</span><span class="punctuation">)</span><span class="name">xrtBOMap</span><span class="punctuation">(</span><span class="name">out_bo_handle</span><span class="punctuation">);</span>
<span class="ln">45 </span>
<span class="ln">46 </span>     <span class="comment single">// Prepare input data
</span><span class="ln">47 </span><span class="comment single"></span>     <span class="name">std</span><span class="operator">::</span><span class="name">copy</span><span class="punctuation">(</span><span class="name">my_float_array</span><span class="punctuation">,</span><span class="name">my_float_array</span><span class="operator">+</span><span class="name">SIZE</span><span class="punctuation">,</span><span class="name">inp_bo_map</span><span class="punctuation">);</span>
<span class="ln">48 </span>
<span class="ln">49 </span>
<span class="ln">50 </span>     <span class="name">xrtAIESyncBO</span><span class="punctuation">(</span><span class="name">device_handle</span><span class="punctuation">,</span> <span class="name">in_bo_handle</span><span class="punctuation">,</span> <span class="literal string">&quot;in_sink&quot;</span><span class="punctuation">,</span> <span class="name">XCL_BO_SYNC_BO_GMIO_TO_AIE</span><span class="punctuation">,</span> <span class="name">SIZE</span> <span class="operator">*</span> <span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">),</span><span class="literal number integer">0</span><span class="punctuation">);</span>
<span class="ln">51 </span>
<span class="ln">52 </span>     <span class="name">xrtAIESyncBO</span><span class="punctuation">(</span><span class="name">device_handle</span><span class="punctuation">,</span> <span class="name">out_bo_handle</span><span class="punctuation">,</span> <span class="literal string">&quot;out_sink&quot;</span><span class="punctuation">,</span> <span class="name">XCL_BO_SYNC_BO_AIE_TO_GMIO</span><span class="punctuation">,</span> <span class="name">SIZE</span> <span class="operator">*</span> <span class="keyword">sizeof</span><span class="punctuation">(</span><span class="keyword type">float</span><span class="punctuation">),</span> <span class="literal number integer">0</span><span class="punctuation">);</span>
</pre>
<p>The above code shows</p>
<blockquote>
<div><ul>
<li><p class="first">Input and output buffer (<code class="docutils literal notranslate"><span class="pre">in_bo_handle</span></code> and <code class="docutils literal notranslate"><span class="pre">out_bo_handle</span></code>) to the graph are created and mapped to the user space</p>
</li>
<li><p class="first">The API <code class="docutils literal notranslate"><span class="pre">xrtAIESyncBO</span></code> is used for data transfer using the following arguments</p>
<blockquote>
<div><ul>
<li><p class="first">Device and Buffer Handle</p>
</li>
<li><p class="first">The name of the GMIO ports associated with the DMA transfer</p>
</li>
<li><p class="first">The direction of the buffer transfer</p>
<blockquote>
<div><ul class="simple">
<li>GMIO to Graph: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_GMIO_TO_AIE</span></code></li>
<li>Graph to GMIO: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_AIE_TO_GMIO</span></code></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">The size and the offset of the buffer</p>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="xrt-error-api">
<h2>XRT Error API<a class="headerlink" href="#xrt-error-api" title="Permalink to this headline">¶</a></h2>
<p>In general, XRT APIs can encounter two types of errors:</p>
<blockquote>
<div><ul class="simple">
<li>Synchronous error: Error can be thrown by the API itself. These types of errors should be checked against all APIs (strongly recommended).</li>
<li>Asynchronous error: Errors from the underneath driver, system, hardware, etc.</li>
</ul>
</div></blockquote>
<p>XRT provides a couple of APIs to retrieve the asynchronous errors into the userspace host code. This helps to debug when something goes wrong.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">xrtErrorGetLast</span></code> - Gets the last error code and its timestamp of a given error class</li>
<li><code class="docutils literal notranslate"><span class="pre">xrtErrorGetString</span></code> - Gets the description string of a given error code.</li>
</ul>
</div></blockquote>
<p><strong>NOTE</strong>: The asynchronous error retrieving APIs are at an early stage of development and only supports AIE related asynchronous errors. Full support for all other asynchronous errors is planned in a future release.</p>
<p>Example code</p>
<pre class="code c++ literal-block">
<span class="ln">41 </span>     <span class="name">rval</span> <span class="operator">=</span> <span class="name">xrtGraphRun</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="name">runInteration</span><span class="punctuation">);</span>
<span class="ln">42 </span>     <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rval</span> <span class="operator">!=</span> <span class="literal number integer">0</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">43 </span>         <span class="comment multiline">/* code to handle synchronous xrtGraphRun error */</span>
<span class="ln">44 </span>         <span class="keyword">goto</span> <span class="name">fail</span><span class="punctuation">;</span>
<span class="ln">45 </span>     <span class="punctuation">}</span>
<span class="ln">46 </span>
<span class="ln">47 </span>     <span class="name">rval</span> <span class="operator">=</span> <span class="name">xrtGraphWaitDone</span><span class="punctuation">(</span><span class="name">graphHandle</span><span class="punctuation">,</span> <span class="name">timeout</span><span class="punctuation">);</span>
<span class="ln">48 </span>     <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rval</span> <span class="operator">==</span> <span class="operator">-</span><span class="name">ETIME</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">49 </span>         <span class="comment multiline">/* wait Graph done timeout without further information */</span>
<span class="ln">50 </span>         <span class="name">xrtErrorCode</span> <span class="name">errCode</span><span class="punctuation">;</span>
<span class="ln">51 </span>         <span class="keyword type">uint64_t</span> <span class="name">timestamp</span><span class="punctuation">;</span>
<span class="ln">52 </span>
<span class="ln">53 </span>         <span class="name">rval</span> <span class="operator">=</span> <span class="name">xrtErrorGetLast</span><span class="punctuation">(</span><span class="name">devHandle</span><span class="punctuation">,</span> <span class="name">XRT_ERROR_CLASS_AIE</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">errCode</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">timestamp</span><span class="punctuation">);</span>
<span class="ln">54 </span>         <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rval</span> <span class="operator">==</span> <span class="literal number integer">0</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">55 </span>             <span class="keyword type">size_t</span> <span class="name">len</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">56 </span>             <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">xrtErrorGetString</span><span class="punctuation">(</span><span class="name">devHandle</span><span class="punctuation">,</span> <span class="name">errCode</span><span class="punctuation">,</span> <span class="keyword">nullptr</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">,</span> <span class="operator">&amp;</span><span class="name">len</span><span class="punctuation">))</span>
<span class="ln">57 </span>                 <span class="keyword">goto</span> <span class="name">fail</span><span class="punctuation">;</span>
<span class="ln">58 </span>             <span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span> <span class="name">buf</span><span class="punctuation">(</span><span class="name">len</span><span class="punctuation">);</span>  <span class="comment single">// or C equivalent
</span><span class="ln">59 </span><span class="comment single"></span>             <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">xrtErrorGetString</span><span class="punctuation">(</span><span class="name">devHandle</span><span class="punctuation">,</span> <span class="name">errCode</span><span class="punctuation">,</span> <span class="name">buf</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span> <span class="name">buf</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">()))</span>
<span class="ln">60 </span>                 <span class="keyword">goto</span> <span class="name">fail</span><span class="punctuation">;</span>
<span class="ln">61 </span>             <span class="comment multiline">/* code to deal with this specific error */</span>
<span class="ln">62 </span>             <span class="name">std</span><span class="operator">::</span><span class="name">cout</span> <span class="operator">&lt;&lt;</span> <span class="name">buf</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">()</span> <span class="operator">&lt;&lt;</span> <span class="name">std</span><span class="operator">::</span><span class="name">endl</span><span class="punctuation">;</span>
<span class="ln">63 </span>         <span class="punctuation">}</span>
<span class="ln">64 </span>    <span class="punctuation">}</span>
<span class="ln">65 </span>    <span class="comment multiline">/* more code can be added here to check other error class */</span>
</pre>
<p>The above code shows</p>
<blockquote>
<div><ul class="simple">
<li>As good practice synchronous error checking is done directly against all APIs (line 41,47,53,56,59)</li>
<li>After timeout occurs from <code class="docutils literal notranslate"><span class="pre">xrtGraphWaitDone</span></code> the API <code class="docutils literal notranslate"><span class="pre">xrtErrorGetLast</span></code> is called to retrieve asynchronous error code (line 53)</li>
<li>Using the error code API <code class="docutils literal notranslate"><span class="pre">xrtErrorGetString</span></code> is called to get the length of the error string (line 56)</li>
<li>The API <code class="docutils literal notranslate"><span class="pre">xrtErrorGetString</span></code> called again for the second time to get the full error string (line 59)</li>
</ul>
</div></blockquote>
</div>
</div>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="opencl_extension.html" class="btn btn-neutral float-left" title="Xilinx OpenCL extension" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="xrt_native.main.html" class="btn btn-neutral float-right" title="XRT Native Library C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2022, Xilinx, Inc. Xilinx is now a part of AMD.
      <span class="lastupdated">Last updated on July 20, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="https://pages.gitenterprise.xilinx.com/techdocs/Test/vvas/build/html/index.html#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>